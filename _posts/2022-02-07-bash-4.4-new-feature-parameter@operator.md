---
layout: post
title: "bash-4.4 new feature ${param@Q} ${parameter@operator}"
---

## What
最近浏览 bash man page，看到一个特性 ${parameter@operator}，发现是 bash-4.4 引入的  
(RHEL-7 默认 bash-4.2.x, RHEL-8 默认 bash-4.4.x)。其中 ${var@Q} 很好的解决了我的一  
个痛点：自动给变量输出加上引用(但是边界处理有点瑕疵)；让我们看看它的效果

## Examples
var
```
$ var='abc\$ "'
$ echo \$var=$var --- \${var@Q}=${var@Q}
$var=abc\$ " --- ${var@Q}='abc\$ "'

$ var=\''abc\$'\'xyz\'
$ echo \$var=$var --- \${var@Q}=${var@Q}
$var='abc\$'xyz' --- ${var@Q}=''\''abc\$'\''xyz'\'''   #前后会多出来两对加引用的空字符 ''

$ var=
$ echo \$var=$var --- \${var@Q}=${var@Q}
$var= --- ${var@Q}=''

$ var=___$'a\nb .*-= z"'\'
$ echo ${var}
___a b .*-= z"'
$ echo "${var}"
___a
b .*-= z"'
$ echo ${var@Q}
$'___a\nb .*-= z"\''
$ echo "${var@Q}"
$'___a\nb .*-= z"\''
```

array
```
$ args() { echo "$@"; echo ${@@Q}; echo "${@@Q}"; echo "${*@Q}"; }
$ args === abc "" \' \" \$ ' '  $'a\nb"'\'
=== abc  ' " $   a
b"'
'===' 'abc' '' \' '"' '$' ' ' $'a\nb"\''
'===' 'abc' '' \' '"' '$' ' ' $'a\nb"\''
'===' 'abc' '' \' '"' '$' ' ' $'a\nb"\''
```


## 用途
对我来说，这个功能很适合编写 run() exec() 之类函数: run command arg1 arg2 arg3 ,,,
以往如果需要从命令行透传一个命令行，然后在脚本里 ssh 或 bash -c "" 执行，会遇到很大的麻烦  

比如下面这个两函数 \_nsexec() 如果遇到参数里有特殊字符的话，是需要特殊额外加一层保护的  
```
_nsexec() {
        local initpid=$1; shift

        nsenter --target "$initpid" --mount --uts --ipc --net --pid -- bash -c "$*"
}
_sshexec() {
        local sshserv=$1; shift

        ssh $sshOption root@$sshserv "$*"
}
```

如果希望以更自然的方式传递的命令行参数，需要自己处理参数，改为如下写法:
```
getSafeCommandLine() {
        #if only one parameter, treat it as a piece of script 
        [[ $# = 1 ]] && { echo "$1"; return; }

        for at; do
                if [[ -z "$at" ]]; then
                        echo -n "'' "
                elif [[ "$at" =~ \' ]]; then
                        echo -n "$at" | sed -r -e ':a;$!{N;ba};' \
                            -e "s/'+/'\"&\"'/g" -e "s/^/'/" -e "s/$/' /" \
                            -e "s/^''//" -e "s/'' $/ /"
                else
                        echo -n "'$at' "
                fi
        done
        echo
}
_nsexec2() {
        local initpid=$1; shift
        local _cmdline=$(getSafeCommandLine "$@")

        nsenter --target "$initpid" --mount --uts --ipc --net --pid -- bash -c "$_cmdline"
}
_sshexec2() {
        local sshserv=$1; shift
        local _cmdline=$(getSafeCommandLine "$@")

        ssh $sshOption root@$sshserv "$_cmdline"
}
```

现在有了 ${@@Q} ${\*@Q} 的话，就不需要自己再实现 getSafeCommandLine 了:
```
_nsexec3() {
        local initpid=$1; shift
        local _cmdline=$1

        [[ $# > 1 ]] && _cmdline="${*@Q}"
        nsenter --target "$initpid" --mount --uts --ipc --net --pid -- bash -c "$_cmdline"
}
_sshexec3() {
        local sshserv=$1; shift
        local _cmdline=$1;

        [[ $# > 1 ]] && _cmdline="${*@Q}"
        ssh $sshOption root@$sshserv "$_cmdline"
}
```

## details compare
```
_sshexec() {
        local sshserv=$1; shift
        ssh $sshOption root@$sshserv "$*"
}
# _sshexec  $addr  echo "'/exportdir *(rw,no_root_squash)'" \>/etc/exports
# _sshexec  $addr  awk "'\$3 ~ /xyz/ {print \$1}'" /etc/abc.conf
# _sshexec  $addr  'test "$(cmdx arg)" = "string" && cmdy'

_sshexec3() {
        local sshserv=$1; shift
        local _cmdline=$1;
        [[ $# > 1 ]] && _cmdline="${*@Q}"
        ssh $sshOption root@$sshserv "$_cmdline"
}
# _sshexec3 $addr  echo  '/exportdir *(rw,no_root_squash)'  \>/etc/exports  #simple than _sshexec
# _sshexec3 $addr  awk  '$3 ~ /xyz/ {print $1}'  /etc/abc.conf              #simple than _sshexec
# _sshexec3 $addr  'test "$(cmdx arg)" = "string" && cmdy'                  #same as _sshexec

#** _sshexec2 与 _sshexec3 功能相同

```
